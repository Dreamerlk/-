<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MongoDB的安装启动和常用命令</title>
    <style type="text/css" media="all">
      body {
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif;
        font-size: 14px;
        line-height: 20px;
        color: #777;
        background-color: white;
      }
      .container {
        width: 700px;
        margin-right: auto;
        margin-left: auto;
      }

      .post {
        font-family: Georgia, "Times New Roman", Times, "SimSun", serif;
        position: relative;
        padding: 70px;
        bottom: 0;
        overflow-y: auto;
        font-size: 16px;
        font-weight: normal;
        line-height: 25px;
        color: #515151;
      }

      .post h1{
        font-size: 50px;
        font-weight: 500;
        line-height: 60px;
        margin-bottom: 40px;
        color: inherit;
      }

      .post p {
        margin: 0 0 35px 0;
      }

      .post img {
        border: 1px solid #D9D9D9;
      }

      .post a {
        color: #28A1C5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="post">
        <h1 class="title">MongoDB的安装启动和常用命令</h1>
        <div class="show-content">
          <p><b>NoSql数据库优缺点</b><br></p><p>在优势方面主要体现在下面几点：</p><p>简单的扩展</p><p>快速的读写</p><p>低廉的成本</p><p>灵活的数据模型</p><p><b>在不足方面主要有下面几点：</b></p><p>不提供对SQL的支持</p><p>支持的特性不够丰富</p><p>现有的产品不够成熟</p><p><b>MongoDB简介</b></p><p>MongoDB是用C++语言编写的非关系型数据库。特点是高性能、易部署、易使用，存储数据十分方便，主要特性有：+</p><p>面向集合存储，易于存储对象类型的数据</p><p>模式自由</p><p>支持动态查询</p><p>支持完全索引，包含内部对象</p><p>支持复制和故障恢复</p><p>使用高效的二进制数据存储，包括大型对象</p><p>文件存储格式为BSON(一种JSON的扩展)</p><p><b>MongoDB基本概念介绍</b></p><p>文档(document)是MongoDB中数据的基本单元，非常类似于关系型数据库系统中的行(但是比行要复杂的多)</p><p>集合(collection)就是一组文档，如果说MongoDB中的文档类似于关系型数据库中的行，那么集合就如同表</p><p>MongoDB的单个计算机可以容纳多个独立的数据库，每一个数据库都有自己的集合和权限</p><p>MongoDB自带简洁但功能强大的JavaScript shell，这个工具对于管理MongoDB实例和操作数据作用非常大</p><p>每一个文档都有一个特殊的键"_id",它在文档所处的集合中是唯一的，相当于关系数据库中的表的主键</p><p><b>MongoDB数据类型</b></p><p><b>数据类型</b><b>描述</b><b>举例</b></p><p>null表示空值或者未定义的对象{"x":null}</p><p>布尔值真或者假：true或者false{"x":true}</p><p>32位整数          32位整数。shell是不支持该类型的，shell中默认会转换成64位浮点数</p><p>64位整数          64位整数。shell是不支持该类型的，shell中默认会转换成64位浮点数</p><p>64位浮点数      64位浮点数。shell中的数字就是这一种类型{"x"：3.14，"y"：3}</p><p>字符串UTF-8字符串{"foo":"bar"}</p><p>符号shell不支持，shell会将数据库中的符号类型的数据自动转换成字符串</p><p>对象id文档的12字节的唯一id{"id": ObjectId()}</p><p>日期从标准纪元开始的毫秒数{"date":new Date()}</p><p>正则表达式      文档中可以包含正则表达式，遵循JavaScript的语法  {"foo":/foobar/i}</p><p>代码文档中可以包含JavaScript代码{"x"：function() {}}</p><p>未定义undefined{"x"：undefined}</p><p>数组值的集合或者列表{"arr": ["a","b"]}</p><p>内嵌文档          文档可以作为文档中某个key的value{"x":{"foo":"bar"}}</p><p>1 安装MongoDB</p><p>MongoDB的安装非常简单，只需要将下载的MongoDB的压缩文件解压到任意目录，并将其中的bin目录加入到系统的path环境变量中即可。</p><p>2 启动MongoDB</p><p>在启动MongoDB之前，要手动创建一个存放MongoDB数据文件的目录，如D:\mongo_data在命令行执行 mongod --dbpath=D:\mongo_data</p><p>小技巧：手动创建一个后缀为bat的文件，文件名任意，内容为： mongod --dbpath=D:\mongo_data，双击此文件就可以启动MongoDB服务，</p><p>不用每次都到命令行执行启动命令</p><p>在启动服务器的shell下可以键入Ctrl-C来完全的停止mongod的运行</p><p>3 连接到MongoDB服务器</p><p>重新开启一个命令行 运行mongo命令</p><p>输入mongo命令默认连接到本地的名称为test的数据库，如果希望连接到远程数据库，可以使用mongo ip:port</p><p>4 常用命令</p><p>数据库操作</p><p>创建数据库,使用命令 use 数据库名称</p><p>use 命令后跟的数据库名，如果存在就进入此数据库，如果不存在就创建，所以这种创建方式又叫隐式创建</p><p>注意：使用命令use mydb1创建数据库后，并没有真正生成对应的数据文件，如果此时退出，此数据库将被删除，只有在此数据库中创建集合后，才会真正生成数据文件</p><p>查看所有数据库，使用命令 show dbs</p><p>查看当前所在数据库，使用命令 db</p><p>集合操作</p><p>查看当前数据库中所有的集合，使用命令 show collections 或使用show tables</p><p>创建集合有两种方式，显示创建和隐式创建</p><p>显示创建可以使用命令 db.createCollection("集合名称")</p><p>隐式创建可以使用命令 db.集合名称.insert({}),指创建集合并同时向集合中插入数据,例如：db.customer.insert({name:”jack”})</p><p>删除集合使用命令：db.集合名称.drop()</p><p>向集合添加文档，使用命令 db.集合名称.insert({})，例如：db.user1.insert({name:”jack”,age:20})</p><p>可以使用下面的循环语句批量插入多个文档</p><p>for(var i=0;i&lt;1000;i++){</p><p>db.hjb.insert({name:”name”+i ,age:i});</p><p>}</p><p>还可以使用db.集合名称.save({})向集合中添加文档，save于insert不同之处为：</p><p>使用insert如果插入的文档中_id已经存在，则不能插入，类似于关系型数据库中的主键冲突</p><p>save方法如果插入的文档中_id已经存在，则执行更新</p><p>删除集合中的文档，使用命令 db.集合名称.remove({删除条件})，不加删除条件为删除集合中的所有文档，</p><p>例如，db.c1.remove() 为删除c1集合中的所有文档，db.c1.remove({name:”user1”})为删除c1集合中name为user1的文档</p><p>查询集合中的文档，可以使用命令 db.集合名称.find({条件})，或者使用 db.集合名称.findOne()  查询第一个文档</p><p>db.customer.find()</p><p>db.customer.find({name:"name5"}) 查询customer集合中name为name5的文档</p><p>查询集合中的文档，返回某些特定的键值</p><p>//返回除了age字段外的所有字段</p><p>db.user.find({age:0});</p><p>//返回tags=tennis除了comments的所有列</p><p>db.posts.find({tag:'tennis'},{comments:0})</p><p>//返回userid=16的name字段</p><p>db.user.find({userid:16},{name:1});</p><p>{"_id":16,"name":"user16"}</p><p>//返回x=john的所有z字段</p><p>db.things.find({x:"john"},{z:1});</p><p>查询集合中的文档 ，使用条件表达式(&lt;, &lt;=, &gt;, &gt;=,!=)</p><p>//大于： field &gt; value</p><p>db.collection.find({field:{$gt:value}});</p><p>//小于： field &lt; value</p><p>db.collection.find({field:{$lt:value}});</p><p>//大于等于： field &gt;= value</p><p>db.collection.find({field:{$gte:value}});</p><p>//小于等于： field &lt;= value</p><p>db.collection.find({field:{$lte:value}});</p><p>//不等于：  field != value</p><p>db.collection.find({field:{$ne:value}});</p><p>查询集合中的文档 ，统计(count)、排序(sort)、分页(skip、limit)</p><p>db.customer.count();</p><p>db.customer.find().count();</p><p>db.customer.find({age:{$lt:5}}).count();</p><p>db.customer.find().sort({age:1}); 降序-1</p><p>db.customer.find().skip(2).limit(3);</p><p>db.customer.find().sort({age:-1}).skip(2).limit(3);</p><p>db.customer.find().sort({age:-1}).skip(2).limit(3).count();</p><p>db.customer.find().sort({age:-1}).skip(2).limit(3).count(0);</p><p>db.customer.find().sort({age:-1}).skip(2).limit(3).count(1);</p><p>查询集合中的文档 ,$all主要用来查询数组中的包含关系，查询条件中只要有一个不包含就不返回</p><p>db.c2.insert({name:"user1",post:[1,2,3,4,5]});</p><p>查询集合中的文档 ,$in，类似于关系型数据库中的IN</p><p>db.cunstomer.find({age:{$in:[3,5,7]}})</p><p>查询集合中的文档 ,$nin，与$in相反</p><p>db.customer.find({age:{$nin:[4]}})</p><p>查询集合中的文档 ,$or，相当于关系型数据库中的OR，表示或者的关系，例如查询name为user2或者age为3的文档，命令为：</p><p>db.customer.find({$or:[{name:”user2”},{age:3}]})</p><p>查询集合中的文档 ,$nor，表示根据条件过滤掉某些数据，例如查询name不是user2，age不是3的文档，命令为：</p><p>db.customer.find({$nor:[{name:”user2”},{age:3}]})</p><p>查询集合中的文档 ,$exists，用于查询集合中存在某个键的文档或不存在某个键的文档，例如查询customer集合中存在name键的所有文档，可以使用 db.customer.find({name:{$exists:1}})，</p><p>$exists:1表示真，指存在</p><p>$exists:0表示假，指不存在</p><p>查询集合中的文档 ，类似于关系型数据库，mongodb中也有游标的概念</p><p>var x =db.customer.find()</p><p>x.hasNext()</p><p>x.next()</p><p>更新集合中的文档，语法如下：</p><p>db.collection.update(criteria,objNew,upsert,multi)</p><p>参数说明：</p><p>criteria:用于设置查询条件的对象</p><p>objNew:用于设置更新内容的对象</p><p>upsert:如果记录已经存在，更新它，否则新增一个记录，取值为0或1</p><p>multi：如果有多个符合条件的记录，是否全部更新，取值为0或1</p><p>注意：默认情况下，只会更新第一个符合条件的记录</p><p>一般情况下后两个参数分别为0,1 ，即：</p><p>db.collection.update(criteria,objNew,0,1)</p><p>更新集合中的文档,将集合中name为user1的文档改成name为jack</p><p>db.c1.update({name:"user1"},{name:"jack"})</p><p>这种修改有两个问题，就是会使用新文档覆盖原来的文档，如果原来文档有多个键，修改后就有可能被覆盖只剩下一个键了</p><p>第二个问题为即使符合更新条件的文档有多个也只会更新第一个符合条件的记录</p><p>更新集合中的文档, $set 用来指定一个键的值，如果这个键不存在，则创建它。例如：</p><p>给name为user1的文档添加address，可以使用命令：</p><p>db.c1.update({name:”user1”},{$set:{address:”bj”}},0,1)</p><p>将name为user1的文档修改address为tj，其它键值对不变,命令为：</p><p>db.c1.update({name:”user1”},{$set:{address:”tj”}},0,1)</p><p>更新集合中的文档,使用 $inc 将集合中name为user1的age加1，其它键不变, $inc表示使某个键值加减指定的数值</p><p>db.c1.update({name:"user1"},{$inc:{age:1}})</p><p>db.c1.find()</p><p>更新集合中的文档, $unset 用来删除某个键，例如删除name为user1的文档中的address键，可以使用命令：</p><p>db.c1.update({name:”user1”},{$unset:{address:1}},0,1)</p><p>5 索引</p><p>索引就是用来加速查询的。数据库索引与书籍的索引类似：有了索引就不需要翻遍整本书，数据库则可以直接在索引中查找，</p><p>使得查找速度能提高几个数量级。在索引中找到条目以后，就可以直接跳转到目标文档的位置。</p><p>创建索引</p><p>创建普通索引，使用命令 db.collection.ensureIndex({key:1})</p><p>查看关于索引的相关信息，使用命令 db.collection.stats()</p><p>查看查询使用索引的情况，使用命令   db.collection.find({key:value}).explain()</p><p>删除索引，使用命令 db.collection.dropIndex({key:1})</p><p>删除集合，也会将集合中的索引全部删除</p><p>?explain是非常有用的工具，会帮助你获得查询方面诸多有用的信息。只要对游标调用该方法，就可以得到查询细节。explain会返回一个文档，而不是游标本身。</p><p>如：&gt;db.test.find().explain()</p><p>{"cursor" : "BasicCursor",</p><p>"nscanned" : 1,</p><p>"nscannedObjects" : 1,</p><p>"n" : 1,</p><p>"millis" : 0,</p><p>"nYields" : 0,</p><p>"nChunkSkips" : 0,</p><p>"isMultiKey" : false,</p><p>"indexOnly" : false,</p><p>"indexBounds" : {}?}</p><p>explain会返回查询使用的索引情况，耗时和扫描文档数的统计信息。</p><p>"cursor":"BasicCursor"表示没有使用索引。</p><p>"nscanned":1 表示查询了多少个文档。</p><p>"n":1 表示返回的文档数量。</p><p>"millis":0 表示整个查询的耗时。</p><p>6 固定集合(capped collection)</p><p>固定集合指的是事先创建而且大小固定的集合 。</p><p>固定集合特性：固定集合很像环形队列，如果空间不足，最早的文档就会被删除，为新的文档腾出空间。一般来说，固定集合适用于任何想要自动淘汰过期属性的场景，没有太多的操作限制。</p><p>创建固定集合使用命令：db.createCollection(“collectionName”,{capped:true,size:100000,max:100});</p><p>size指定集合大小，单位为KB，max指定文档的数量</p><p>当指定文档数量上限时，必须同时指定大小。淘汰机制只有在容量还没有满时才会依据文档数量来工作。要是容量满了，淘汰机制会依据容量来工作。</p><p>将普通集合转换为固定集合 ：</p><p>db.runCommand({convertToCapped:“collectionName",size:10000,max:100});</p><p>7 备份(mongodump)和恢复(mongorestore)</p><p>MongoDB提供了备份和恢复的功能，分别是MongoDB下载目录下的mongodump.exe和mongorestore.exe文件</p><p>备份数据使用下面的命令：</p><p>&gt;mongodump -h dbhost -d dbname -o dbdirectory</p><p>-h：MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017</p><p>-d：需要备份的数据库实例，例如：test</p><p>-o：备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。</p><p>恢复数据使用下面的命令：</p><p>&gt;mongorestore -h dbhost -d dbname -directoryperdb dbdirectory</p><p>-h：MongoDB所在服务器地址</p><p>-d：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2</p><p>-directoryperdb：备份数据所在位置，例如：c:\data\dump\test</p><p>8 导入(mongoimport)和导出(mongoexport)</p><p>导出数据可以使用命令：</p><p>mongoexport -h dbhost -d dbname -c collectionName -o output</p><p>参数说明:</p><p>-h  数据库地址</p><p>-d 指明使用的库</p><p>-c 指明要导出的集合</p><p>-o 指明要导出的文件名</p><p>导入数据可以使用命令：</p><p>mongoimport -h dbhost -d dbname -c collectionname 文件的地址...</p><p>参数说明:</p><p>-h  数据库地址</p><p>-d 指明使用的库</p><p>-c 指明要导入的集合</p><p>本地的文件地址...</p><p>9 安全和认证</p><p>每个MongoDB实例中的数据库都可以有许多用户。如果开启了安全性检查，则只有数据库认证用户才能执行读或者写操作。</p><p>在认证的上下文中，MongoDB会将普通的数据作为admin数据库处理。admin数据库中的用户被视为超级用户(即管理员)。</p><p>在认证之后，管理员可以读写所有数据库，执行特定的管理命令，如listDatabases和shutdown。</p><p>在开启安全检查之前，一定要至少有一个管理员账号。</p><p>在admin数据库中创建管理员账号：</p><p>use admin;</p><p>db.addUser(“root”,”root”);</p><p>在test数据库中创建普通账号：</p><p>use test;</p><p>db.addUser(“zhangsan”,”123”);</p><p>db.addUser(“lisi”,”123”,true);</p><p>注意：用户zhangsan，密码为123，对test数据库拥有读写权限</p><p>用户lisi，密码为123，对test数据库拥有只读权限</p><p>重新启动数据库服务，并开启安全检查：</p><p>mongod --dbpath d:\mongo_data --auth</p><p>10 主从复制(主从集群 ) 重点内容</p><p>主从复制是MongoDB最常用的复制方式。这种方式非常灵活，可用于备份、故障恢复、读扩展等。</p><p>最基本的设置方式就是建立一个主节点和一个或者多个从节点，每个从节点要知道主节点的地址。</p><p>运行mongod --master就启动了主服务器。运行mongod --slave --source master_address 则启动了从服务器，其中master_address就是上面主节点的地址。</p><p>MongoDB的复制至少需要两个服务器或者节点。其中一个是主节点，负责处理客户端请求，其它的都是从节点，负责映射主节点的数据。</p><p>主节点记录在其上执行的所有操作。从节点定期轮询主节点获得这些操作，然后对自己的数据副本执行这些操作。由于和主节点执行了</p><p>相同的操作，从节点就能保持与主节点的数据同步。</p><p>主节点的操作记录成为oplog(operation log)。oplog存储在一个特殊的数据库中，叫做local。oplog就在其中的oplog.$main集合</p><p>里面。oplog中的每个文档都代表主节点上执行的一个操作。需要重点强调的是oplog只记录改变数据库状态的操作。比如，查询就</p><p>不再存储在oplog中。这是因为oplog只是作为从节点与主节点保持数据同步的机制。</p><p>为了方便演示，可以在一台计算机上来模拟主节点和从节点。在D盘创建两个目录master和slave，master目录作为主节点的数据文件的目录，slave目录作为从节点的数据文件的目录。</p><p>注意：主节点和从节点要指定不同的端口。</p><p>启动主节点：mongod --dbpath d:\master --port 10000 --master</p><p>启动从节点：mongod --dbpath d:\slave --port 10001 --slave --source localhost:10000</p><p>启动成功后就可以连接主节点进行操作了，而这些操作会同步到从节点。</p><p>注意：主节点可以进行增删改查所有操作，而从节点只能进行查询的操作</p><p>11 副本集 replset</p><p>副本集就是有自动故障恢复功能的主从集群。</p><p>主从集群和副本集最大的区别就是副本集没有固定的“主节点”；</p><p>整个集群会选出一个“主节点”，当其挂掉后，又在剩下的从节点中选中其他节点为“主节点”，副本集总有一个活跃点(primary)和一个或多个备份节点(secondary)。</p><p>以三个节点为例：</p><p>节点1：</p><p>HOST：localhost:10001</p><p>Log File：D:\mongodb\logs\node1\logs.txt</p><p>Data File：D:\mongodb\dbs\node1</p><p>节点2：</p><p>HOST：localhost:10002</p><p>Log File：D:\mongodb\logs\node2\logs.txt</p><p>Data File：D:\mongodb\dbs\node2</p><p>节点3：</p><p>HOST：localhost:10003</p><p>Log File：D:\mongodb\logs\node3\logs.txt</p><p>Data File：D:\mongodb\dbs\node3</p><p>启动节点1：</p><p>mongod --dbpath D:\mongodb\dbs\node1 --logpath D:\mongodb\logs\node1\logs.txt --logappend --port 10001 --replSet itcast/localhost:10002? --master</p><p>启动节点2：</p><p>mongod --dbpath D:\mongodb\dbs\node2 --logpath D:\mongodb\logs\node2\logs.txt --logappend --port 10002 --replSet itcast/localhost:10001</p><p>启动节点3：??</p><p>mongod --dbpath D:\mongodb\dbs\node3 --logpath D:\mongodb\logs\node3\logs.txt --logappend --port 10003 --replSet itcast/localhost:10001,localhost:10002</p><p>初始化节点(只能初始化一次)：随便登录一个节点,以10001为例</p><p>?mongo localhost:10001/admin</p><p>?db.runCommand({</p><p>"replSetInitiate":{"_id":“itcast",</p><p>"members":[{"_id":1,</p><p>"host":"localhost:10001",</p><p>"priority":3},</p><p>{"_id":2,"host":"localhost:10002","priority":2},{"_id":3,"host":"localhost:10003","priority":1}]}});</p><p>参数解释：</p><p>--replSet? 指定副本集? 后面紧跟着副本集的名称</p><p>--logappend 日志文件末尾添加</p><p>--port 指定端口号</p><p>db.runCommand({})? 初始化副本集</p><p>初始化文档:</p><p>"_id":“itcast",? 指副本集的名称</p><p>?"members":[...]? 副本集的服务器列表? 每个列表有个</p><p>?????????????? "_id": 每个服务器的唯一id,?</p><p>??????????????"host" 指定服务器的主机,</p><p>??????????????"priority"设置优先级，默认优先级为1,可以是1-1000的数字</p><p>查询当前主库，登录10002</p><p>mongo localhost:10002</p><p>db.$cmd.findOne ( {ismaster: 1 } );</p><p>关闭10001服务Dos命令窗口,? 登录10002查询当前主库</p><p>mongo localhost:10002</p><p>db.$cmd.findOne ( {ismaster: 1 } );</p><p>默认情况下从库是不能进行读写操作的设置从库可读(在从库secondary上执行)：</p><p>rs.slaveOk ( );</p><p>12 分片(sharding)分布式存储..</p><p>分片(sharding)是指将数据拆分，将其分散存在不同的机器上的过程。有时也用分区(partitioning)来表示这个概念。</p><p>将数据分散到不同的机器上，不需要功能强大的大型计算机就可以储存更多的数据，处理更多的负载。</p><p>MongoDB分片的基本思想就是将集合切分成小块。这些块分散到若干片里面，每个片只负责总数据的一部分。</p><p>应用程序不必知道哪片对应哪些数据，甚至不需要知道数据已经被拆分了，所以在分片之前要运行一个路由进程，该进程名为mongos。</p><p>这个路由器知道所有数据的存放位置，所以应用可以连接它来正常发送请求。对应用来说，它仅知道连接了一个普通的mongod。</p><p>路由器知道数据和片的对应关系，能够转发请求到正确的片上。如果请求有了回应，路由器将其收集起来回送给应用。</p><p>设置分片时，需要从集合里面选一个键，用该键的值作为数据拆分的依据。这个键称为片键(shard key)。</p><p>{name:"zhangsan",age:1}</p><p>用个例子来说明这个过程：假设有个文档集合表示的是人员。</p><p>如果选择名字("name")作为片键，第一片可能会存放名字以A~F开头的文档，第二片存的G~P的名字，第三片存的Q~Z的名字。</p><p>随着添加或者删除片，MongoDB会重新平衡数据，使每片的流量都比较均衡，数据量也在合理范围内。</p><p>mongos就是一个路由服务器，它会根据管理员设置的“片键”将数据分摊到自己管理的mongod集群，数据和片的对应关系以及相应的配置信息保存在“config服务器”上。</p><p>mongod:一个普通的数据库实例，如果不分片的话，我们会直接连上mongod。</p><p>步骤：</p><p>1、创建三个目录，分别存放两个mongod服务的数据文件和config服务的数据文件</p><p>2、开启config服务器 。mongos要把mongod之间的配置放到config服务器里面，所以首先开启它，这里就使用2222端口。 命令为：</p><p>mongod --dbpath E:\sharding\config_node --port 2222</p><p>3、开启mongos服务器 。这里要注意的是我们开启的是mongos，端口3333，同时指定下config服务器。命令为：</p><p>mongos --port 3333 --configdb=127.0.0.1:2222</p><p>4、启动mongod服务器 。对分片来说，也就是要添加片了，这里开启两个mongod服务，端口分别为：4444，5555。命令为：</p><p>mongod --dbpath E:\sharding\mongod_node1 --port 4444</p><p>mongod --dbpath E:\sharding\mongod_node2 --port 5555</p><p>5、服务配置 。client直接跟mongos打交道，也就说明我们要连接mongos服务器，然后将4444，5555的mongod交给mongos,添加分片也就是addshard()。</p><p>6、开启数据库分片功能，命令很简单 enablesharding(),这里就开启test数据库。</p><p>7、指定集合中分片的片键，这里就指定为person.name键。</p><p>8、通过mongos插入10w记录，然后通过printShardingStatus命令查看mongodb的数据分片情况。</p><p>这里主要看三点信息：</p><p>? ① shards： ? ? 可以看到已经别分为两个片了，shard0000和shard0001。</p><p>? ② databases:：?这里有个partitioned字段表示是否分区，这里可以看到test已经分区。</p><p>? ③ chunks： ? ? 集合被砍成四段：</p><p>? ? ? ? ? ? 无穷小 —— jack0，</p><p>jack0 ——jack234813，</p><p>jack234813——jack9999，</p><p>jack9999——无穷大。</p><p>分区情况为：3：1，从后面的 on shardXXXX也能看得出。</p>
        </div>
      </div>
    </div>
  </body>
</html>
